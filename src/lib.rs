// use full_moon::{
//     ast::{self, Expression},
//     parse,
// };
use luexks_reassembly::{
    shapes::{port::Port, port_flags::PortFlag, ports::Ports, scale::Scale, shape::Shape, shape_id::ShapeId, shapes::Shapes, vertex::vert, vertices::Vertices}, utility::{display_oriented_math::{don_float_from, DisplayOrientedNumber}, flags::Flags}, *
};
use mlua::{Lua, Table, Value};
use regex::Regex;

mod tests {
    use crate::get_vanilla_shapes;

    use crate::blocks::block::*;
    use crate::blocks::blocks::*;
    use crate::blocks::feature::*;
    use crate::r#mod::Mod;
    use crate::shapes::shapes::Shapes;
    use crate::utility::color::Color;
    use crate::utility::flags::*;
    use crate::utility::funky_string::*;
    use luexks_reassembly::*;

    #[test]
    fn create_vanilla_shape_mod() {
        const USER: &str = "ALX";
        const MOD_NAME: &str = "Vanilla Shape Mod";
        pub const GROUP: i32 = 78;

        let mod_path = create_mod_folder_and_get_mod_path(USER, MOD_NAME);

        let blocks = &mut Blocks::default();
        println!("####################################");
        let shapes = &mut get_vanilla_shapes();
        println!("####################################");

        blocks.add_blocks(
            block!(
                name: funky_string!("Test Hull"),
                blurb: funky_string!("This block's shape was parsed from the vanilla shapes.lua."),
                features: explicit_features!(
                    Palette,
                ),
                group: GROUP,
                color_1: Color::new_rrggbb("7f6538"),
                color_2: Color::new_rrggbb("49351f"),
                line_color: Color::new_rrggbb("221e0f"),
                durability: 4.0,
                density: 0.2,
            )
            .to_extended_blocks_from_plural_shapes(&shapes.0),
        );

        let r#mod = Mod {
            blocks_option: Some(blocks),
            shapes_option: Some(shapes),
        };

        // dbg!(&r#mod);
        println!("Just debugged.");

        write_mod(mod_path, r#mod);
    }
}

pub fn get_vanilla_shapes() -> Shapes {
    let vanilla_shapes = std::fs::read_to_string("shapes.lua").unwrap();
    // let re = Regex::new(r"([A-Z_]+)").unwrap();
    let re = Regex::new(r"\{\s*([A-Z_][A-Z0-9_]*)\s*,").unwrap();
    // let vanilla_shapes = re.replace_all(&vanilla_shapes, "\"$1\"");
    let vanilla_shapes = re.replace_all(&vanilla_shapes, "{ \"$1\",");
    // println!("{}", vanilla_shapes);
    let lua = Lua::new();
    let shapes_table: mlua::Table = lua.load(&format!("return {}", vanilla_shapes)).eval().unwrap();

    let mut shapes = Shapes::default();

    // println!("{:?}", shapes_table);

    for shape_table in shapes_table.sequence_values::<mlua::Table>() {
        // println!("{:?}", pair.unwrap().)
        let shape = shape_table.unwrap();
        // let id = ShapeId::Vanilla(shape.get(1).unwrap());
        let id = ShapeId::Vanilla(shape.get(1).unwrap());
        let scales_table: Table = shape.get(2).unwrap();
        for scale_table in scales_table.sequence_values::<mlua::Table>() {
            let scale = scale_table.unwrap();
            // println!("{:?}", scale);
        }
        // let shape = Shape::Standard { id: , scales: () };

    }

    //     let src = r#"
    // -- autogenerated shape export file
    // return {
    //   {SQUARE, {{verts={{5, -5}, {-5, -5}, {-5, 5}, {5, 5}}, ports={{3, 0.5}, {0, 0.5}}}}},
    // }
    // "#;

    //     let ast = parse(src).expect("Failed to parse Lua");

    // println!("{:#?}", ast);

    // let vanilla_shapes = std::fs::read_to_string("shapes.lua").unwrap();
    // let vanilla_shapes = format!("return {}", vanilla_shapes);
    // let ast = parse(&vanilla_shapes).expect("Failed to parse shapes.lua.");

    // // println!("{:#?}", ast);

    // // let mut shapes = Shapes::default();

    // let shapes = if let Some(last_stmt) = ast.nodes().last_stmt() {
    //     if let ast::LastStmt::Return(ret) = last_stmt {
    //         if let Some(expr) = ret.returns().first() {
    //             if let ast::Expression::TableConstructor(table) = expr.value() {
    //                 table
    //             } else {
    //                 panic!()
    //             }
    //         } else {
    //             panic!()
    //         }
    //     } else {
    //         panic!()
    //     }
    // } else {
    //     panic!()
    // };
    // let mut a = Vec::new();
    // for field in shapes.fields() {
    //     if let ast::Field::NoKey(expr) = field {
    //         if let ast::Expression::TableConstructor(shape_table) = expr {
    //             if let Some(shape) = extract_shape(shape_table) {
    //                 shapes_file.shapes.push(shape);
    //             }
    //         }
    //     }
    // }

    // todo!()

    // let lua_code = std::fs::read_to_string("shapes.lua").unwrap();
    // let lua = Lua::new();
    // let shapes_table: Table = lua.load(&format!("return {}", lua_code)).eval().unwrap();

    let mut shapes_vec = Vec::new();

    for shape_value in shapes_table.sequence_values::<Table>() {
        let shape = shape_value.unwrap();

        // Get first element (name) as Value
        let name_value: Value = shape.get(1).unwrap();

        let name = if let Value::String(s) = name_value {
            s.to_str().unwrap().to_string()
        } else {
            panic!()
        };

        let scales_table: Table = shape.get(2).unwrap();

        let mut scales_vec = Vec::new();
        for scale_value in scales_table.sequence_values::<Table>() {
            let scale = scale_value.unwrap();

            let verts_table: Table = scale.get("verts").unwrap();
            let verts = Vertices(verts_table.sequence_values::<Table>()
                .map(|v| {
                    let v = v?;
                    let x: f32 = v.get(1)?;
                    let y: f32 = v.get(2)?;
                    Ok(vert!(x, y))
                })
                .collect::<Result<_, mlua::Error>>()
                .unwrap());

            let ports_table: Table = scale.get("ports").unwrap();
            let ports = Ports(
                ports_table.sequence_values::<Table>()
                    .map(|p| {
                        let p = p?;
                        let side_index: usize = p.get(1)?;
                        let lerp: f32 = p.get(2)?;
                        Ok(Port {
                            side_index,
                            position: DisplayOrientedNumber::Float(lerp),
                            flags: Flags(vec![PortFlag::Normal]),
                        })
                    })
                    .collect::<Result<Vec<_>, mlua::Error>>()
                    .unwrap()
            );

            scales_vec.push(Scale { verts, ports, name: name.clone() });
        }

        shapes_vec.push(Shape::Standard {
            id: ShapeId::Vanilla(name),
            scales: scales_vec,
        });
    }

    // dbg!(&shapes_vec);
    Shapes(shapes_vec)
}
